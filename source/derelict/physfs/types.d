/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.physfs.types;

// 2.0 Types
alias PHYSFS_uint8 = ubyte;
alias PHYSFS_sint8 = byte;
alias PHYSFS_uint16 = ushort;
alias PHYSFS_sint16 = short;
alias PHYSFS_uint32 = uint;
alias PHYSFS_sint32 = int;
alias PHYSFS_uint64 = ulong;
alias PHYSFS_sint64 = long;

struct PHYSFS_File {
    void* opaque;
}

struct PHYSFS_ArchiveInfo {
    const(char)* extension;
    const(char)* description;
    const(char)* author;
    const(char)* url;
    int supportSymlinks;
}

struct PHYSFS_Version {
    PHYSFS_uint8 major;
    PHYSFS_uint8 minor;
    PHYSFS_uint8 patch;
}

enum ubyte PHYSFS_VERSION_MAJOR = 2;
enum ubyte PHYSFS_VERSION_MINOR = 1;
enum ubyte PHYSFS_VERSION_PATCH = 0;

void PHYSFS_VERSION(ref PHYSFS_Version* x) {
    x.major = PHYSFS_VERSION_MAJOR;
    x.minor = PHYSFS_VERSION_MINOR;
    x.patch = PHYSFS_VERSION_PATCH;
}

struct PHYSFS_Allocator {
    int function() Init;
    void function() Deinit;
    void* function(PHYSFS_uint64) Malloc;
    void* function(void*, PHYSFS_uint64) Realloc;
    void function(void*) Free;
}

extern(C) nothrow {
    alias PHYSFS_StringCallback = void function(void*, const(char)*);
    alias PHYSFS_EnumFilesCallback = void function(void*, const(char)*, const(char)*);
}

// 2.1 Types
alias PHYSFS_FileType = int;
enum {
    PHYSFS_FILETYPE_REGULAR,
    PHYSFS_FILETYPE_DIRECTORY,
    PHYSFS_FILETYPE_SYMLINK,
    PHYSFS_FILETYPE_OTHER
}

struct PHYSFS_Stat {
    PHYSFS_sint64 filesize;
    PHYSFS_sint64 modtime;
    PHYSFS_sint64 createtime;
    PHYSFS_sint64 accesstime;
    PHYSFS_FileType filetype;
}

struct PHYSFS_Io {
    PHYSFS_uint32 version_;
    void* opaque;
    extern(C) nothrow {
        PHYSFS_sint64 function(PHYSFS_Io*, void*, PHYSFS_uint64) read;
        PHYSFS_sint64 function(PHYSFS_Io*, const(void)*, PHYSFS_uint64) write;
        PHYSFS_sint64 function(PHYSFS_Io*) tell;
        PHYSFS_sint64 function(PHYSFS_Io*) length;
        PHYSFS_Io* function(PHYSFS_Io*) duplicate;
        int function(PHYSFS_Io*) flush;
        void function(PHYSFS_Io*) destroy;
    }
}

// This is not an explicit type in PHYSFS, just for convenience
// here to get the nothrow attribute only.
extern(C) nothrow alias UnmountCallback = void function(void*);

alias PHYSFS_ErrorCode = int;
enum {
    PHYSFS_ERR_OK,
    PHYSFS_ERR_OTHER_ERROR,
    PHYSFS_ERR_OUT_OF_MEMORY,
    PHYSFS_ERR_NOT_INITIALIZED,
    PHYSFS_ERR_IS_INITIALIZED,
    PHYSFS_ERR_ARGV0_IS_NULL,
    PHYSFS_ERR_UNSUPPORTED,
    PHYSFS_ERR_PAST_EOF,
    PHYSFS_ERR_FILES_STILL_OPEN,
    PHYSFS_ERR_INVALID_ARGUMENT,
    PHYSFS_ERR_NOT_MOUNTED,
    PHYSFS_ERR_NOT_FOUND,
    PHYSFS_ERR_SYMLINK_FORBIDDEN,
    PHYSFS_ERR_NO_WRITE_DIR,
    PHYSFS_ERR_OPEN_FOR_READING,
    PHYSFS_ERR_OPEN_FOR_WRITING,
    PHYSFS_ERR_NOT_A_FILE,
    PHYSFS_ERR_READ_ONLY,
    PHYSFS_ERR_CORRUPT,
    PHYSFS_ERR_SYMLINK_LOOP,
    PHYSFS_ERR_IO,
    PHYSFS_ERR_PERMISSION,
    PHYSFS_ERR_NO_SPACE,
    PHYSFS_ERR_BAD_FILENAME,
    PHYSFS_ERR_BUSY,
    PHYSFS_ERR_DIR_NOT_EMPTY,
    PHYSFS_ERR_OS_ERROR,
    PHYSFS_ERR_DUPLICATE
}

struct PHYSFS_Archiver {
    PHYSFS_uint32 version_;
    PHYSFS_ArchiveInfo info;
    extern(C) nothrow {
        void* function(PHYSFS_Io*, const(char)*, int) openArchive;
        void function(void*, const(char)*, PHYSFS_EnumFilesCallback, const(char)*, void*) enumerateFiles;
        PHYSFS_Io* function(void*, const(char)*) openRead;
        PHYSFS_Io* function(void*, const(char)*) openWrite;
        PHYSFS_Io* function(void*, const(char)*) openAppend;
        int function(void*, const(char)*) remove;
        int function(void*, const(char)*) mkdir;
        int function(void*, const(char)*, PHYSFS_Stat*) stat;
        void function(void*) closeArchive;
    }
}